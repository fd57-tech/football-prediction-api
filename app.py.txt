"""
API de pr√©diction football avec mod√®le Bayesian hi√©rarchique
D√©ployable sur Render.com
"""

import os
import json
import requests
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from typing import Dict, List, Optional

# FastAPI et d√©pendances
from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import uvicorn

# Machine Learning
from sklearn.ensemble import RandomForestClassifier, GradientBoostingRegressor
from sklearn.preprocessing import StandardScaler
import pickle
from scipy.stats import poisson

# Configuration depuis les variables d'environnement
PHP_BRIDGE_URL = os.getenv('PHP_BRIDGE_URL', 'https://appdevfoot.leselixirsdedamenature.fr/api_bridge_enhanced.php')
PHP_SECRET = os.getenv('PHP_SECRET', 'TonSecret2024')
PORT = int(os.getenv('PORT', 8000))

# Cr√©er l'application FastAPI
app = FastAPI(
    title="Football Prediction API",
    description="API de pr√©diction avec mod√®le Bayesian et ML ensemble",
    version="2.0"
)

# Configuration CORS pour permettre les requ√™tes depuis PHP
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ==================== MOD√àLES DE DONN√âES ====================

class MatchFeatures(BaseModel):
    """Features d'un match pour la pr√©diction"""
    home_form: float = 0.5
    away_form: float = 0.5
    h2h_home_wins: int = 0
    h2h_draws: int = 0
    h2h_away_wins: int = 0
    home_goals_avg: float = 1.5
    away_goals_avg: float = 1.2
    home_defense: float = 1.0
    away_defense: float = 1.3
    days_since_last_home: int = 3
    days_since_last_away: int = 3
    league_position_home: int = 10
    league_position_away: int = 12

class PredictionRequest(BaseModel):
    """Requ√™te de pr√©diction"""
    match_id: int
    home_team: str
    away_team: str
    competition: str = "Unknown"
    features: Optional[MatchFeatures] = None
    odds_consensus: Optional[Dict] = None

class OddsConsensus(BaseModel):
    """Consensus des bookmakers"""
    home_odd: float
    draw_odd: float
    away_odd: float
    bookmakers: List[str] = []

# ==================== MOD√àLE BAYESIAN ====================

class BayesianPoissonModel:
    """
    Mod√®le Bayesian Hi√©rarchique pour pr√©diction football
    Utilise une distribution de Poisson avec priors Gamma
    """
    
    def __init__(self, alpha_prior=1.5, beta_prior=1.5):
        self.alpha_prior = alpha_prior
        self.beta_prior = beta_prior
        self.team_strengths = {}
        self.league_effects = {}  # Effet hi√©rarchique par ligue
        
    def fit(self, training_data):
        """
        Entra√Æne le mod√®le sur les donn√©es historiques
        Impl√©mente la hi√©rarchie : Ligue -> √âquipe -> Match
        """
        if isinstance(training_data, list):
            df = pd.DataFrame(training_data)
        else:
            df = training_data
            
        # Calculer les effets par ligue (niveau hi√©rarchique sup√©rieur)
        for league in df['competition_name'].unique():
            league_matches = df[df['competition_name'] == league]
            avg_goals = (league_matches['home_score'].mean() + 
                        league_matches['away_score'].mean()) / 2
            self.league_effects[league] = avg_goals / 1.5  # Normaliser autour de 1.5
        
        # Calculer les forces d'√©quipes avec effet de ligue
        all_teams = pd.concat([df['home_team'], df['away_team']]).unique()
        
        for team in all_teams:
            home_matches = df[df['home_team'] == team]
            away_matches = df[df['away_team'] == team]
            
            # Buts marqu√©s et encaiss√©s
            goals_home = home_matches['home_score'].sum() if len(home_matches) > 0 else 0
            goals_away = away_matches['away_score'].sum() if len(away_matches) > 0 else 0
            conceded_home = home_matches['away_score'].sum() if len(home_matches) > 0 else 0
            conceded_away = away_matches['home_score'].sum() if len(away_matches) > 0 else 0
            
            n_matches = len(home_matches) + len(away_matches)
            
            if n_matches > 0:
                # Mise √† jour Bay√©sienne avec prior informatif
                alpha_attack = self.alpha_prior + goals_home + goals_away
                beta_attack = self.beta_prior + n_matches
                
                alpha_defense = self.alpha_prior + conceded_home + conceded_away
                beta_defense = self.beta_prior + n_matches
                
                # Calculer la force avec shrinkage vers la moyenne de la ligue
                attack_strength = alpha_attack / beta_attack
                defense_strength = alpha_defense / beta_defense
                
                # Facteur de confiance bas√© sur le nombre de matchs
                confidence = min(1.0, n_matches / 20)  # Confiance max apr√®s 20 matchs
                
                # Moyenne de ligue pour le shrinkage
                team_leagues = pd.concat([
                    home_matches['competition_name'],
                    away_matches['competition_name']
                ]).value_counts()
                
                if len(team_leagues) > 0:
                    main_league = team_leagues.index[0]
                    league_factor = self.league_effects.get(main_league, 1.0)
                else:
                    league_factor = 1.0
                
                # Appliquer le shrinkage vers la moyenne de la ligue
                attack_strength = confidence * attack_strength + (1 - confidence) * 1.5 * league_factor
                defense_strength = confidence * defense_strength + (1 - confidence) * 1.5 * league_factor
                
            else:
                # Pas de donn√©es : utiliser les priors
                attack_strength = 1.5
                defense_strength = 1.5
                confidence = 0.0
            
            self.team_strengths[team] = {
                'attack': attack_strength,
                'defense': defense_strength,
                'matches_played': n_matches,
                'confidence': confidence
            }
    
    def predict_match(self, home_team, away_team, competition=None, odds_consensus=None):
        """
        Pr√©dit un match avec consensus des bookmakers optionnel
        """
        # R√©cup√©rer les forces des √©quipes
        home_stats = self.team_strengths.get(home_team, {
            'attack': 1.5, 'defense': 1.5, 'confidence': 0
        })
        away_stats = self.team_strengths.get(away_team, {
            'attack': 1.3, 'defense': 1.3, 'confidence': 0
        })
        
        # Effet de ligue si disponible
        league_factor = self.league_effects.get(competition, 1.0) if competition else 1.0
        
        # Lambda pour la distribution de Poisson
        home_lambda = home_stats['attack'] * away_stats['defense'] * 1.148 * league_factor  # Avantage domicile
        away_lambda = away_stats['attack'] * home_stats['defense'] * 0.87 * league_factor
        
        # Matrice de probabilit√©s pour tous les scores possibles
        max_goals = 8
        prob_matrix = np.zeros((max_goals, max_goals))
        
        for i in range(max_goals):
            for j in range(max_goals):
                prob_matrix[i, j] = poisson.pmf(i, home_lambda) * poisson.pmf(j, away_lambda)
        
        # Calculer les probabilit√©s de r√©sultat
        home_win = np.sum(np.tril(prob_matrix, -1))
        draw = np.sum(np.diag(prob_matrix))
        away_win = np.sum(np.triu(prob_matrix, 1))
        
        # Int√©grer le consensus des bookmakers si disponible
        if odds_consensus:
            # Convertir les cotes en probabilit√©s
            if 'odds' in odds_consensus:
                home_odd = odds_consensus['odds'].get('home', 0)
                draw_odd = odds_consensus['odds'].get('draw', 0)
                away_odd = odds_consensus['odds'].get('away', 0)
                
                if home_odd > 0 and draw_odd > 0 and away_odd > 0:
                    # Probabilit√©s implicites des bookmakers
                    total_inv = 1/home_odd + 1/draw_odd + 1/away_odd
                    market_home = (1/home_odd) / total_inv
                    market_draw = (1/draw_odd) / total_inv
                    market_away = (1/away_odd) / total_inv
                    
                    # Pond√©ration : plus de confiance au march√© pour les grandes ligues
                    market_weight = 0.4 if competition and 'priority' in self.league_effects else 0.3
                    
                    home_win = (1 - market_weight) * home_win + market_weight * market_home
                    draw = (1 - market_weight) * draw + market_weight * market_draw
                    away_win = (1 - market_weight) * away_win + market_weight * market_away
        
        # Normaliser pour que la somme = 1
        total = home_win + draw + away_win
        if total > 0:
            home_win /= total
            draw /= total
            away_win /= total
        
        # Calculer les scores les plus probables
        most_likely_score = np.unravel_index(prob_matrix.argmax(), prob_matrix.shape)
        
        # Calculer la confiance (combinaison de plusieurs facteurs)
        confidence = min(home_stats['confidence'], away_stats['confidence'])
        confidence = confidence * 0.7 + max([home_win, draw, away_win]) * 0.3
        
        return {
            'probabilities': {
                'home': round(home_win, 3),
                'draw': round(draw, 3),
                'away': round(away_win, 3)
            },
            'expected_goals': {
                'home': round(home_lambda, 2),
                'away': round(away_lambda, 2),
                'total': round(home_lambda + away_lambda, 2),
                'over_2.5': round(1 - sum([prob_matrix[i, j] for i in range(3) for j in range(3) if i + j <= 2]), 3),
                'btts': round(1 - (sum(prob_matrix[0, :]) + sum(prob_matrix[:, 0]) - prob_matrix[0, 0]), 3)
            },
            'most_likely_score': f"{most_likely_score[0]}-{most_likely_score[1]}",
            'confidence': round(confidence, 3),
            'model': 'bayesian_hierarchical'
        }

# ==================== CLASSE PRINCIPALE DE PR√âDICTION ====================

class FootballPredictor:
    """
    Classe principale qui combine tous les mod√®les
    """
    
    def __init__(self):
        self.bayesian_model = BayesianPoissonModel()
        self.rf_model = None
        self.xgb_model = None
        self.scaler = StandardScaler()
        self.is_trained = False
        self.training_date = None
        
    def fetch_training_data(self):
        """
        R√©cup√®re les donn√©es d'entra√Ænement depuis PHP
        """
        try:
            response = requests.post(
                PHP_BRIDGE_URL,
                data={
                    'secret': PHP_SECRET,
                    'action': 'get_training_data',
                    'limit': 2000
                }
            )
            
            if response.status_code == 200:
                data = response.json()
                return data.get('matches', [])
            else:
                print(f"Erreur lors de la r√©cup√©ration des donn√©es : {response.status_code}")
                return []
                
        except Exception as e:
            print(f"Erreur de connexion au bridge PHP : {e}")
            return []
    
    def train(self):
        """
        Entra√Æne tous les mod√®les
        """
        print("üîÑ R√©cup√©ration des donn√©es d'entra√Ænement...")
        training_data = self.fetch_training_data()
        
        if len(training_data) < 100:
            print(f"‚ö†Ô∏è Seulement {len(training_data)} matchs disponibles. Entra√Ænement minimal.")
            
        if training_data:
            # Entra√Æner le mod√®le Bayesian
            print(f"üìä Entra√Ænement du mod√®le Bayesian sur {len(training_data)} matchs...")
            self.bayesian_model.fit(training_data)
            
            # TODO: Ajouter l'entra√Ænement des mod√®les ML (Random Forest, XGBoost)
            # Pour l'instant, on se concentre sur le Bayesian qui est le plus important
            
            self.is_trained = True
            self.training_date = datetime.now()
            print("‚úÖ Entra√Ænement termin√© avec succ√®s")
            
            # Sauvegarder le mod√®le
            self.save_model()
        else:
            print("‚ùå Aucune donn√©e d'entra√Ænement disponible")
    
    def save_model(self):
        """
        Sauvegarde le mod√®le entra√Æn√©
        """
        try:
            model_data = {
                'bayesian_team_strengths': self.bayesian_model.team_strengths,
                'bayesian_league_effects': self.bayesian_model.league_effects,
                'training_date': self.training_date.isoformat() if self.training_date else None,
                'is_trained': self.is_trained
            }
            
            with open('model_cache.json', 'w') as f:
                json.dump(model_data, f)
                
            print("üíæ Mod√®le sauvegard√© dans model_cache.json")
            
        except Exception as e:
            print(f"‚ùå Erreur lors de la sauvegarde : {e}")
    
    def load_model(self):
        """
        Charge un mod√®le sauvegard√©
        """
        try:
            if os.path.exists('model_cache.json'):
                with open('model_cache.json', 'r') as f:
                    model_data = json.load(f)
                
                self.bayesian_model.team_strengths = model_data['bayesian_team_strengths']
                self.bayesian_model.league_effects = model_data['bayesian_league_effects']
                self.is_trained = model_data['is_trained']
                
                if model_data['training_date']:
                    self.training_date = datetime.fromisoformat(model_data['training_date'])
                
                print(f"‚úÖ Mod√®le charg√© (entra√Æn√© le {self.training_date})")
                return True
                
        except Exception as e:
            print(f"‚ö†Ô∏è Impossible de charger le mod√®le : {e}")
            
        return False
    
    def predict(self, home_team: str, away_team: str, competition: str = None, 
               features: MatchFeatures = None, odds_consensus: Dict = None):
        """
        Effectue une pr√©diction compl√®te
        """
        if not self.is_trained:
            # Essayer de charger un mod√®le sauvegard√©
            if not self.load_model():
                # Si pas de mod√®le, entra√Æner
                self.train()
        
        # Pr√©diction Bayesienne (toujours disponible)
        bayesian_pred = self.bayesian_model.predict_match(
            home_team, away_team, competition, odds_consensus
        )
        
        # TODO: Ajouter les pr√©dictions ML quand elles seront impl√©ment√©es
        
        # Pour l'instant, retourner uniquement la pr√©diction Bayesienne
        prediction = bayesian_pred
        
        # D√©terminer le r√©sultat le plus probable
        probs = prediction['probabilities']
        if probs['home'] > probs['draw'] and probs['home'] > probs['away']:
            prediction['predicted_outcome'] = 'HOME'
        elif probs['draw'] > probs['away']:
            prediction['predicted_outcome'] = 'DRAW'
        else:
            prediction['predicted_outcome'] = 'AWAY'
        
        return prediction

# ==================== INSTANCE GLOBALE DU PR√âDICTEUR ====================

predictor = FootballPredictor()

# ==================== ENDPOINTS DE L'API ====================

@app.on_event("startup")
async def startup_event():
    """
    Appel√© au d√©marrage de l'API
    """
    print("üöÄ D√©marrage de l'API de pr√©diction football...")
    print(f"üì° Bridge PHP configur√© : {PHP_BRIDGE_URL}")
    
    # Charger ou entra√Æner le mod√®le
    if not predictor.load_model():
        print("üîÑ Aucun mod√®le en cache, entra√Ænement initial...")
        predictor.train()
    
    print("‚úÖ API pr√™te √† recevoir des requ√™tes")

@app.get("/")
def root():
    """
    Endpoint de test et d'information
    """
    return {
        "status": "online",
        "service": "Football Prediction API",
        "version": "2.0",
        "model": {
            "trained": predictor.is_trained,
            "training_date": predictor.training_date.isoformat() if predictor.training_date else None,
            "teams_in_model": len(predictor.bayesian_model.team_strengths),
            "leagues_in_model": len(predictor.bayesian_model.league_effects)
        },
        "endpoints": {
            "predictions": "/predict",
            "batch_predictions": "/predict/batch",
            "model_info": "/model/info",
            "retrain": "/model/retrain"
        }
    }

@app.post("/predict")
async def predict_match(request: PredictionRequest):
    """
    Endpoint principal de pr√©diction pour un match
    """
    try:
        # Si pas de features, les r√©cup√©rer depuis PHP
        if not request.features:
            response = requests.post(
                PHP_BRIDGE_URL,
                data={
                    'secret': PHP_SECRET,
                    'action': 'get_match_features',
                    'match_id': request.match_id
                }
            )
            
            if response.status_code == 200:
                features_data = response.json()
                # Convertir en MatchFeatures
                # TODO: Mapper les donn√©es correctement
            else:
                # Utiliser les valeurs par d√©faut
                features = MatchFeatures()
        else:
            features = request.features
        
        # Effectuer la pr√©diction
        prediction = predictor.predict(
            request.home_team,
            request.away_team,
            request.competition,
            features,
            request.odds_consensus
        )
        
        # Ajouter les informations du match
        prediction['match_info'] = {
            'match_id': request.match_id,
            'home_team': request.home_team,
            'away_team': request.away_team,
            'competition': request.competition
        }
        
        # Stocker la pr√©diction dans la base via PHP
        store_response = requests.post(
            PHP_BRIDGE_URL,
            json={
                'secret': PHP_SECRET,
                'action': 'store_prediction',
                'match_id': request.match_id,
                'predicted_outcome': prediction['predicted_outcome'],
                'home_probability': prediction['probabilities']['home'],
                'draw_probability': prediction['probabilities']['draw'],
                'away_probability': prediction['probabilities']['away'],
                'confidence': prediction['confidence'],
                'expected_goals_home': prediction['expected_goals']['home'],
                'expected_goals_away': prediction['expected_goals']['away'],
                'models_used': [prediction['model']]
            }
        )
        
        if store_response.status_code == 200:
            prediction['stored'] = True
        else:
            prediction['stored'] = False
        
        return prediction
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/predict/batch")
async def predict_batch(background_tasks: BackgroundTasks):
    """
    Pr√©dit tous les matchs √† venir (ex√©cut√© en arri√®re-plan)
    """
    background_tasks.add_task(process_upcoming_matches)
    
    return {
        "status": "processing",
        "message": "Batch prediction started in background"
    }

async def process_upcoming_matches():
    """
    Traite tous les matchs √† venir
    """
    try:
        # R√©cup√©rer les matchs √† venir depuis PHP
        response = requests.post(
            PHP_BRIDGE_URL,
            data={
                'secret': PHP_SECRET,
                'action': 'get_upcoming_matches',
                'hours': 48
            }
        )
        
        if response.status_code == 200:
            data = response.json()
            matches = data.get('matches', [])
            
            print(f"üìä Traitement de {len(matches)} matchs √† venir...")
            
            for match in matches:
                if not match.get('prediction_exists'):
                    # Cr√©er la requ√™te de pr√©diction
                    request = PredictionRequest(
                        match_id=match['id'],
                        home_team=match['home_team'],
                        away_team=match['away_team'],
                        competition=match.get('competition_name', 'Unknown')
                    )
                    
                    # Effectuer la pr√©diction
                    await predict_match(request)
                    
            print(f"‚úÖ Batch prediction termin√©")
            
    except Exception as e:
        print(f"‚ùå Erreur dans le batch prediction : {e}")

@app.get("/model/info")
def get_model_info():
    """
    Informations d√©taill√©es sur le mod√®le
    """
    # Top 10 √©quipes par force d'attaque
    top_attack = sorted(
        predictor.bayesian_model.team_strengths.items(),
        key=lambda x: x[1]['attack'],
        reverse=True
    )[:10]
    
    # Top 10 √©quipes par force d√©fensive (plus bas = meilleur)
    top_defense = sorted(
        predictor.bayesian_model.team_strengths.items(),
        key=lambda x: x[1]['defense']
    )[:10]
    
    return {
        "model_status": {
            "trained": predictor.is_trained,
            "training_date": predictor.training_date.isoformat() if predictor.training_date else None,
            "total_teams": len(predictor.bayesian_model.team_strengths),
            "total_leagues": len(predictor.bayesian_model.league_effects)
        },
        "top_attack_teams": [
            {
                "team": team,
                "attack_strength": round(stats['attack'], 2),
                "matches_played": stats['matches_played']
            }
            for team, stats in top_attack
        ],
        "top_defense_teams": [
            {
                "team": team,
                "defense_strength": round(stats['defense'], 2),
                "matches_played": stats['matches_played']
            }
            for team, stats in top_defense
        ],
        "league_effects": predictor.bayesian_model.league_effects
    }

@app.post("/model/retrain")
async def retrain_model(background_tasks: BackgroundTasks):
    """
    R√©entra√Æne le mod√®le avec les derni√®res donn√©es
    """
    background_tasks.add_task(predictor.train)
    
    return {
        "status": "retraining",
        "message": "Model retraining started in background"
    }

@app.get("/health")
def health_check():
    """
    Health check pour Render
    """
    return {"status": "healthy"}

# ==================== LANCEMENT DE L'APPLICATION ====================

if __name__ == "__main__":
    # Utiliser le port fourni par Render
    uvicorn.run(app, host="0.0.0.0", port=PORT)